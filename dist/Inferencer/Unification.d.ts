import { Result } from "../Utils/Result";
import { MonoTy, PolyTy, TyConst, TypeEnv, TyVar } from "./Types";
export declare type TypeSubst = Record<TyVar['value'], MonoTy>;
export declare const unify: (s: MonoTy, t: MonoTy) => Result<TypeSubst, string>;
export declare const directedUnify: (s: MonoTy, t: MonoTy) => Result<TypeSubst, string>;
export declare function substituteMono(x: TyVar, sig: TypeSubst, excluded?: TyVar['value'][]): Result<MonoTy, string>;
export declare function substituteMono(t: TyConst, sig: TypeSubst, excluded?: TyVar['value'][]): Result<TyConst, string>;
export declare function substituteMono(m: MonoTy, sig: TypeSubst, excluded?: TyVar['value'][]): Result<MonoTy, string>;
export declare const freeVarsMonoTy: (ty: MonoTy, acc?: Set<TyVar['value']>) => Set<TyVar['value']>;
export declare const freeVarsPolyTy: ({ polyVars, ty }: PolyTy, acc?: Set<TyVar['value']>) => Set<TyVar['value']>;
export declare const freeVarsEnv: (env: TypeEnv) => Set<TyVar['value']>;
export declare function substitutePoly(t: PolyTy, sig: TypeSubst): Result<PolyTy, string>;
export declare const substituteEnv: (env: TypeEnv, sig: TypeSubst) => Result<TypeEnv, string>;
export declare const substCompose: (sig1: TypeSubst, ...sigs: TypeSubst[]) => Result<TypeSubst, string>;
export declare const substOf: (vars: TyVar['value'][], tys: MonoTy[]) => TypeSubst;
export declare const showSubst: (subst: TypeSubst) => string;
