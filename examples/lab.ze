
data Bool = True | False;
data List a = Nil | Cons a (List a);
data Nat = S Nat | Zero;

class Show a where
    show : a -> List Char;

instance Show Char where
    show c = [c];

instance Show Bool where
    show True = "True",
    show False = "False";

instance Show (List Char) where
    show str = str;

instance (Show a) => Show (List a) where
    show [] = "[]",
    show lst = flatten ["[", join "," (map show lst), "]"];

instance Show Nat where
    show Zero = "0",
    show (S prev) = flatten ["S(", show prev, ")"];

map _ [] = [];
map f h::tl = (f h)::(map f tl);

prepend as [] = as;
prepend [] bs = bs;
prepend a::as bs = a :: (prepend as bs);

append as bs = prepend bs as;

flatten lists = flatten' lists [];
flatten' [] acc = acc;
flatten' lst::lists acc = flatten' lists (append lst acc);

intercalate _ [] = [];
intercalate _ [x] = [x];
intercalate sep h::tl = h::sep::(intercalate sep tl);

join sep lst = flatten (intercalate sep lst);

not False = True;
not True = False;

class Eq a where
    eq : a -> a -> Bool;

neq x y = not (eq x y);

instance Eq Bool where
    eq True True = True,
    eq False False = True,
    eq _ _ = False;

instance (Eq a) => Eq (List a) where
    eq [] [] = True,
    eq a::as b::bs = if eq a b then eq as bs else False,
    eq _ _ = False;

instance Eq Nat where
    eq Zero Zero = True,
    eq (S a) (S b) = eq a b,
    eq _ _ = False;

instance Eq Char where
    eq c1 c2 = c1 == c2;

instance Eq Int where
    eq n m = n == m;

any _ [] = False;
any pred x::xs = if pred x then True else any pred xs;

elem x = any (\y -> eq x y);

main = show (eq [1, 2, 3] [1, 2, 5]);