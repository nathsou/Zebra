
data Bool = True | False;
data List a = Nil | Cons a (List a);
data Nat = S Nat | Zero;

class Eq a where
    eq : a -> a -> Bool;

class Show a where
    show : a -> List Char;

instance Show Bool where
    show True = "True",
    show False = "False";

instance Show Nat where
    show Zero = "0",
    show (S prev) = flatten ["S(", show prev, ")"];

-- instance Eq Nat where
--     eq Zero Zero = True,
--     eq (S a) (S b) = eq a b,
--     eq _ _ = False;

map _ [] = [];
map f h::tl = (f h)::(map f tl);

prepend as [] = as;
prepend [] bs = bs;
prepend a::as bs = a :: (prepend as bs);

append as bs = prepend bs as;

flatten lists = flatten' lists [];
flatten' [] acc = acc;
flatten' lst::lists acc = flatten' lists (append lst acc);

intercalate _ [] = [];
intercalate _ [x] = [x];
intercalate sep h::tl = h::sep::(intercalate sep tl);

join sep lst = flatten (intercalate sep lst);

instance (Show a) => Show (List a) where
    show [] = "[]",
    show lst = flatten ["[", join "," (map show lst), "]"];

not False = True;
not True = False;

instance Eq Bool where
    eq True True = True,
    eq False False = True,
    eq _ _ = False;

instance (Eq a) => Eq (List a) where
    eq [] [] = True,
    -- FIXME: ajouter une fun decl pour chaque couple (method, type)
    eq a::as b::bs = if eq a b then eq as bs else False,
    eq _ _ = False;

any _ [] = False;
any pred x::xs = if pred x then True else any pred xs;

-- elem : (a -> Bool) -> List a -> Bool;
elem x = any (\y -> eq x y);

instance Show Char where
    show c = [c];

main = eq [False, True] [False, True];