
data Bool = True | False;
data List a = Nil | Cons a (List a);
data Nat = S Nat | Zero;

class Eq a where
    eq : a -> a -> Bool,
    neq : a -> a -> Bool;

class Show a where
    show : a -> List Char;

instance Show Bool where
    show True = "True",
    show False = "False";

instance Show Nat where
    show Zero = "0",
    show (S prev) = flatten ["S(", show prev, ")"];

instance Eq Nat where
    eq Zero Zero = True,
    eq (S a) (S b) = eq a b,
    eq _ _ = False,
    neq a b = not (eq a b);

map _ [] = [];
map f h::tl = (f h)::(map f tl);

prepend as [] = as;
prepend [] bs = bs;
prepend a::as bs = a :: (prepend as bs);

append as bs = prepend bs as;

flatten lists = flatten' lists [];
flatten' [] acc = acc;
flatten' lst::lists acc = flatten' lists (append lst acc);

intercalate _ [] = [];
intercalate _ [x] = [x];
intercalate sep h::tl = h::sep::(intercalate sep tl);

join sep lst = flatten (intercalate sep lst);

instance (Show a) => Show (List a) where
    show [] = "[]",
    show lst = flatten ["[", join "," (map show lst), "]"];

not False = True;
not True = False;

intEq x y = x == y;
intNeq x y = x == y;

instance Eq Int where
    eq x y = x == y,
    neq x y = not (x == y);

instance Eq Bool where
    eq True True = True,
    eq False False = True,
    eq _ _ = False,
    neq p q = not (eq p q);

instance (Eq a) => Eq (List a) where
    eq [] [] = True,
    eq a::as b::bs = if eq a b then eq as bs else False,
    eq _ _ = False,
    neq as bs = not (eq as bs);

elem _ [] = False;
elem x y::ys = if eq x y then True else elem x ys;

main = elem;